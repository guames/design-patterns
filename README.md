# All Design Patterns 

## Behavioral Patterns
#### Command
###### Call:
patterns.behavioral.command.RunCommand.main(args);
###### When you use this pattern:
#### Interpreter
###### Call:
patterns.behavioral.interpreter.RunInterpreter.main(args);
###### When you use this pattern:
#### Iterator
###### Call:
patterns.behavioral.iterator.RunIterator.main(args);
###### When you use this pattern:
#### Mediator
###### Call:
patterns.behavioral.mediator.RunMediator.main(args);
###### When you use this pattern:
#### Memento
###### Call:
patterns.behavioral.memento.RunMemento.main(args);
###### When you use this pattern:
#### Observer
###### Call:
patterns.behavioral.observer.RunObserver.main(args);
###### When you use this pattern:
#### State
###### Call:
patterns.behavioral.state.RunState.main(args);
###### When you use this pattern:
#### Strategy
###### Call:
patterns.behavioral.strategy.RunStrategy.main(args);
###### When you use this pattern:
#### Templatemethod
###### Call:
patterns.behavioral.templatemethod.RunTemplateMethod.main(args);
###### When you use this pattern:
#### Visitor
###### Call:
patterns.behavioral.visitor.RunVisitor.main(args);
###### When you use this pattern:

## Creational Patterns 
#### Abstractfactory
###### Call:
patterns.creational.abstractfactory.RunAbstractFactory.main(args);
###### When you use this pattern:
#### Builder
###### Call:
patterns.creational.builder.RunBuilder.main(args);
###### When you use this pattern:
#### Factorymethod
###### Call:
patterns.creational.factorymethod.RunFactoryMethod.main(args);
###### When you use this pattern:
#### Prototype
###### Call:
patterns.creational.prototype.RunPrototype.main(args);
###### When you use this pattern:
#### Singleton
###### Call:
patterns.creational.singleton.RunSingleton.main(args);
###### When you use this pattern:

## Structural Patterns
#### Adapter
###### Call:
patterns.structural.adapter.RunAdapter.main(args);
###### When you use this pattern:
* There is an existing class, and its interface does not match the one you need.
* You want to create a reusable class that cooperates with unrelated or unforeseen classes, that is, classes that don’t necessarily have compatible interfaces.
* There are several existing subclasses to be use, but it’s impractical to adapt their interface by subclassing every one. An object adapter can adapt the interface of its parent class.

#### Bridge
###### Call:
patterns.structural.bridge.RunBridge.main(args);
###### When you use this pattern:
#### Composite
###### Call:
patterns.structural.composite.RunComposite.main(args);
###### When you use this pattern:
#### Decorator
###### Call:
patterns.structural.decorator.RunDecorator.main(args);
###### When you use this pattern:
#### Facade
###### Call:
patterns.structural.facade.RunFacade.main(args);
###### When you use this pattern:
#### Flyweight
###### Call:
patterns.structural.flyweight.RunFlyweight.main(args);
###### When you use this pattern:
#### Proxy
###### Call:
patterns.structural.proxy.RunProxy.main(args);
###### When you use this pattern:


## Reference from Book "Java Design Patterns" by Rohit Joshi
